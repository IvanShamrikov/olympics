# Магічна функція
#
# Нещодавно Козак Вус відвідав лекцію з математики. Після лекції він придумав наступну задачу.
# Нехай є 2 масиви a та b з n елементів. Тоді f(i,j)= a[i] * b[j] + b[i] * a[j], де 1≤i<j≤n.
# Козака Вуса дуже зацікавило максимальне значення функції f(i,j), де 1≤i<j≤n.
# Козак Вус вже стомився розв'язувати цю задачу, тому він просить Вас допомогти йому.
#
# Вхідні дані
# Перший рядок містить одне ціле число n (2≤n≤10^5) — довжина масивів a та b.
# Другий рядок містить n цілих чисел a[1], a[2], ... , a[n]  (1≤ a[i] ≤10^6) — масив a.
# Третій рядок містить n цілих чисел b[1], b[2], ... , b[n]  (0≤ b[i] ≤10^3) — масив b.
#
# Вихідні дані
# Виведіть єдине число — максимальне значення функції f(i,j), де 1≤i<j≤n.
#
# Приклади
# Вхідні дані #1
# 3
# 5 4 6
# 1 2 3
# Відповідь #1
# 24
#
# Вхідні дані #2
# 5
# 2 3 4 4 5
# 5 4 4 3 1
# Відповідь #2
# 28
#
# У першому прикладі можна вибрати i=2 та j=3, тоді f(2,3)= a[2] * b[3] + b[2] * a[3] = 4⋅3+2⋅6= =12+12=24
# У другому прикладі можна вибрати i=3 та j=4, тоді f(3,4)= a[3] * b[4] + b[3] * a[4] = 4⋅3+4⋅4= =12+16=28



n = int(input())

a = input().split()
for i in range(len(a)):
    a[i] = int(a[i])

b = input().split()
for i in range(len(b)):
    b[i] = int(b[i])

max = 0
for i in range(n):
    for j in range(i+1, n): # i+1 проставлено тому, що в умові задачі j завжди більший за i . Тому він починається не з 0, а з i+1
        res = a[i]*b[j] + a[j]*b[i]
        if res > max:
            max = res

print(max)




#------------------------------------------------------



# Перевод римьских чисел в звичайні і навпаки

# Римські цифри представлені сімома різними символами: I, V, X, L, C, D та M.
#
# Символ       Значення
# I             1
# V             5
# X             10
# L             50
# C             100
# D             500
# M             1000
# Наприклад, 2 пишеться як II у римських цифрах, просто два одиничні додані разом. 12 пишеться як XII, що просто X + II.
# Число 27 пишеться як XXVII, що є XX + VI + I.
#
# Римські цифри зазвичай пишуться від найбільшої до найменшої зліва направо.
# Однак, число чотири не пишеться як IIII. Замість цього, число чотири пишеться як IV.
# Оскільки одиниця стоїть перед п'ятіркою, ми віднімаємо її, утворюючи чотири.
# Те ж саме стосується числа дев'ять, яке пишеться як IX. Існує шість випадків, коли використовується віднімання:
#
# I можна поставити перед V (5) та X (10), щоб отримати 4 і 9.
# X можна поставити перед L (50) та C (100), щоб отримати 40 і 90.
# C можна поставити перед D (500) та M (1000), щоб отримати 400 і 900.
# Задача: перетворити римське число на ціле число.
#
# Example 1:
#
# Input: s = "III"
# Output: 3
# Explanation: III = 3.
# Example 2:
#
# Input: s = "LVIII"
# Output: 58
# Explanation: L = 50, V= 5, III = 3.
# Example 3:
#
# Input: s = "MCMXCIV"
# Output: 1994
# Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.



def int_to_roman(num):
    print("Int to Romanian")
    num_map = {
        1: "I", #однобуквені
        5: "V",
        10: "X",
        50: "L",
        100: "C",
        500: "D",
        1000: "M",

        4: "IV", #двобуквені
        9: "IX",
        40: "XL",
        90: "XC",
        400: "CD",
        900: "CM",

    }
    result = ""
    for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]: # перебираємо числа від більшого до меньшого в рамках заданого діапазона
        # If n in list then add the roman value to result variable
        while n <= num: #зменьшуємо основне число поки воно не стане меньше за n
            result += num_map[n]  # додаємо букву (вибірка з словника по ключу) до строки
            num -= n # зменьшуємо основне число на значення букви, яку вже додали до строки
    return result


def roman_to_int(roman):
    print("Romanian to int")
    num_map = {
        "I": 1,  # однобуквені
        "V": 5,
        "X": 10,
        "L": 50,
        "C": 100,
        "D": 500,
        "M": 1000,

        "IV": 4,  # двобуквені
        "IX": 9,
        "XL": 40,
        "XC": 90,
        "CD": 400,
        "CM": 900

    }
    result = 0

    i = 0
    while i < len(roman): # проходимось по індексам букв
        if i+1 < len(roman) and roman[i:i+2] in num_map: # якщо є можливість розглянути пару букв і ця пара є в двобуквених сполуках
                result += num_map[roman[i:i+2]] # до результату додається число, що відповідає двобуквеній сполуці
                i+=2 # індекс перепригує на 2 пункту, бо ми використали двобуквену сполуку.
        else:
            result += num_map[roman[i]]  # до результату додається число, що відповідає однобуквеній сполуці
            i+=1

    return result




#------------------------------------------------------


# Picture: https://leetcode.com/problems/projection-area-of-3d-shapes/description/
 #
 # Вам дано сітку розміром n x n, де ми розміщуємо деякі кубики розміром 1 x 1 x 1, які вирівняні по осях x, y та z.
 # Кожне значення v = grid[i][j] представляє вежу з v кубиків, розміщених на клітинці (i, j).
 # Ми спостерігаємо проекцію цих кубиків на площини xy, yz та zx.
 # Проекція подібна до тіні, яка відображає нашу тривимірну фігуру на двовимірну площину.
 # Ми бачимо "тінь", коли дивимося на кубики зверху, спереду та збоку.
 # Поверніть загальну площу всіх трьох проекцій.
 #
 # Input: grid = [[1,2],[3,4]]
 # Output: 17
 # Explanation: Ось три проекції ("тіні") фігури, утвореної на кожній площині, вирівняній за осями.
 #
 # Example 2:
 # Input: grid = [[2]]
 # Output: 5
 #
 # Example 3:
 # Input: grid = [[1,0],[0,2]]
 # Output: 8


grid = [[1,2],[3,4]]
print(f"Схема висоток в місті = {grid}")
xy = 0 #тіні на землі
xz = 0 #бокові тіні по стороні Х
yz = 0 #бокові тіні по стороні У
maximum = 0 #технічна змінна для знаходження найбільшого будинку на вулиці, який відкидуює тінь, що поглинає всі інші тіні.

for i in range(len(grid)):
    print(f"Розглядаємо вулицю {i} по горизонталі X. Там стоять такі будинки =  {grid[i]}")
    xz += max(grid[i])
    print(f"На сторону XZ буде падати тінь найвищого будинку  = {max(grid[i])}, додаємо її значення до загального лічільника тіней по стороні XZ. Це буде {xz} клітин")

    maximum = 0 #скидаємо показник макусимальної тіні по yz

    print(f"Проходимось по вертикальним будинками.")
    for j in range (len(grid[i])):
        print(f"Ідемо по стовпчику {i} і рядку {j}")
        if grid[i][j] > 0:
            xy += 1
            print(f"Тут стоїть дім висотою {grid[i][j]}. По підлозі xy він займає 1 клітину. Додаємо +1 до загального лічільника тіней по землі XУ ")
        else:
            print(f"Тут дім не стоїть, тіні неа землю не відбрасує, нічого не додаємо до загального лічільника тіней по землі XУ ")

        print(f"Ідемо по стовпчику {j} і рядку {i}")
        if grid[j][i] > maximum:
            print(f"Тут стоїть дім висотою {grid[j][i]}. Його висота поки є найбільшою серед вертикалі, тому запамятаємо його тінь як найвищу поки шо")
            maximum = grid[j][i]
        else:
            print(f"Тут стоїть дім висотою {grid[j][i]}. Його висота не перевищує висоту попереднього найбільшого будинку в цій вертикалі ({maximum}), тому тінь по цій вертикалі залишається {maximum}")


    yz += maximum
    print("-"*25)

print(f"xy = ", xy)
print(f"xz = ", xz)
print(f"zy = ", yz)
print(xy + xz + yz)


